# ADR-20251030: معماری لایه‌ای برای Backend

**تاریخ**: 2025-10-30  
**وضعیت**: پذیرفته شده ✅  
**تصمیم‌گیرنده**: تیم توسعه Minila

---

## 1. مسأله

برای توسعه MVP پلتفرم Minila (هماهنگی مسافر-بار)، نیاز به یک معماری backend داریم که:

- **قابل نگهداری** باشد و با رشد پروژه پیچیده نشود
- **قابل تست** باشد و بتوانیم هر لایه را جداگانه تست کنیم
- **مقیاس‌پذیر** باشد و بتوان به راحتی فیچر جدید اضافه کرد
- مطابق با **بهترین شیوه‌های FastAPI** باشد
- برای توسعه‌دهندگان جدید **قابل درک** باشد

بدون یک ساختار مشخص، کدها به سرعت به هم می‌ریزند و نگهداری سخت می‌شود.

---

## 2. گزینه‌های بررسی شده

### گزینه A: معماری Monolithic ساده
```
app/
  main.py         # همه چیز در یک فایل
  models.py       # فقط مدل‌ها
  routes.py       # فقط روت‌ها
```

**مزایا**: سریع برای شروع، کد کمتر  
**معایب**: پیچیدگی سریع، تست سخت، coupling بالا

### گزینه B: معماری لایه‌ای (Layered Architecture) ⭐
```
app/
  api/routers/    # Endpoints
  api/deps.py     # Dependencies
  core/           # Config, security, utils
  models/         # ORM models
  schemas/        # Pydantic schemas
  services/       # Business logic
  repositories/   # Data access
```

**مزایا**: جداسازی واضح، تست آسان، مقیاس‌پذیری بالا  
**معایب**: کد بیشتر در ابتدا، نیاز به discipline

### گزینه C: معماری Hexagonal (Ports & Adapters)
```
domain/          # Domain logic (مستقل کامل)
  entities/
  use_cases/
adapters/        # اتصال به دنیای خارج
  web/
  database/
```

**مزایا**: استقلال کامل domain، تست عالی  
**معایب**: پیچیدگی بالا برای MVP، over-engineering

---

## 3. انتخاب

**معماری لایه‌ای (گزینه B)** را انتخاب کردیم.

---

## 4. دلیل انتخاب

1. **Separation of Concerns**: هر لایه یک مسئولیت دارد
   - Routers: فقط ورودی/خروجی HTTP
   - Services: منطق کسب‌وکار
   - Repositories: دسترسی به دیتابیس
   
2. **قابلیت تست بالا**: می‌توانیم هر لایه را با mock کردن لایه زیرین تست کنیم

3. **مطابق با FastAPI**: این الگو در مستندات FastAPI توصیه شده است

4. **تعادل بین سادگی و مقیاس‌پذیری**: برای MVP پیچیده نیست، اما برای رشد آماده است

5. **Onboarding سریع‌تر**: توسعه‌دهنده جدید می‌داند کجا دنبال چه چیزی بگردد

6. **تغییرپذیری**: اگر خواستیم FastAPI را عوض کنیم، فقط لایه API تغییر می‌کند

---

## 5. تأثیر بر آینده

### مثبت ✅
- توسعه‌دهندگان جدید **سریع‌تر** یاد می‌گیرند
- تست‌نویسی **آسان‌تر** است (هر لایه جدا)
- اضافه کردن فیچر جدید **ساختاریافته** است
- Refactoring **امن‌تر** است (تغییرات محدود می‌مانند)
- تغییر فریم‌ورک یا دیتابیس **ممکن** است

### چالش‌ها ⚠️
- در ابتدا **کد بیشتری** نوشته می‌شود
- نیاز به **انضباط تیمی** برای رعایت لایه‌ها
- خطر **over-abstraction** (باید مراقب بود)

### قوانین برای آینده
1. **هیچ منطق کسب‌وکار در routers نباشد**
2. **هیچ import از FastAPI در services نباشد**
3. **Repositories فقط DB query بزنند، منطق نداشته باشند**

---

## منابع و مراجع

- [FastAPI Best Practices](https://fastapi.tiangolo.com/tutorial/bigger-applications/)
- [Layered Architecture Pattern](https://martinfowler.com/bliki/LayeredArchitecture.html)
- فایل `ARCHITECTURE.md` برای جزئیات بیشتر

